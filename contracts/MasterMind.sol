//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;


import "hardhat/console.sol";

contract MasterMind {

    uint randNonce = 0; //random seed
    uint public noColors = 6;
    uint public size = 4;
    string private solCombination; //stores the solution combination generated by the game
    string private hint= ""; //stores the hint generated in the current turn
    uint private turn = 0; //current turn on the player
    uint private chances = 10; //total number of chances
    string[] allCombinations; //stores all combinations entered
    string[] progress; //stores all the progress of corresponding combinations

    //Mapping for comparing the user combination and creating the hints
    mapping(uint => uint) guess_match;
    uint[] guess_values;
    uint[] user_array;  //frequency array for user
    uint[] sol_array = new uint[](noColors); //frequency array for solution
    uint[] guess_array = new uint[](4); //stores the user guess
    uint[] guess_peg = new uint[](4); //stores the peg value

    //0) Generate random combination: DONE
    //1) function to receive solution from the react app or generate the solution combination
    //1.1) We can also take money from the sender first to play the game 
    //Functions to create
    //verify combination
    //generate progress
    //update turn: The other option is turn is provided and updated by the react app


    constructor(string memory _Combination) {
        console.log("Deploying a Greeter with greeting:", _Combination);
        solCombination = _Combination;
    }
    

    //USED: https://stackoverflow.com/questions/47129173/how-to-convert-uint-to-string-in-solidity
    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {
        if (_i == 0) {
            return "0";
        }
        uint j = _i;
        uint len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len;
        while (_i != 0) {
            k = k-1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }

    function stringToUint(string memory s) public returns (uint result) {
        bytes memory b = bytes(s);
        uint i;
        result = 0;
        for (i = 0; i < b.length; i++) {
            uint c = uint(uint8(b[i]));
            if (c >= 48 && c <= 57) {
                result = result * 10 + (c - 48);
            }
        }
        return result;
    }

    //returns a private random number
    function random() private returns (uint) {
        randNonce++;
        return uint(keccak256(abi.encodePacked(block.prevrandao, block.timestamp, msg.sender, randNonce)));
    } 

    function generate_combination() public {
        uint[] memory colors = new uint[](size); 
        string memory solution = "";
        for (uint256 i = 0; i < size; i++) {
            colors[i] = random() % noColors;
            solution = string.concat(solution, uint2str(colors[i]));
        }
        console.log("%s", solution);
        solCombination = solution;
        bytes memory sol = bytes(solCombination);
        bytes memory s = new bytes(1);

        //store solution frequency in sol_array
        for(uint i = 0; i < sol.length; i++)
        { 
            s[0] = sol[i];
            sol_array[stringToUint(string(s))]++;
        }


    }

    function set_combination(string memory sol) public {
        solCombination = sol;
    }

    function getNewCombination() public view returns (string memory) {
        console.log("%s", solCombination);
        return solCombination;
    }

    function updateTurn() public returns (bool success) {
        require(chances > turn); //require that another chance is available TODO: Change this to returning false
        turn++;
        return true;
    }

    function verifyCombination(string memory userCombination) public view returns (bool success) {
        // if (updateTurn()){
            //This means we have a turn available
        bytes memory user = bytes(userCombination);
        bytes memory sol = bytes(solCombination);
        bytes memory u = new bytes(1);
        bytes memory s = new bytes(1);
        bool combMatch = true;

        for(uint i = 0; i < sol.length; i++)
        {
            u[0] = user[i];
            s[0] = sol[i];
            if(u[0] != s[0])
               combMatch = false; 
        }
        console.logBool(combMatch);
        return combMatch;
    }


    // function reset_mapping() public {
    //     for(uint i = 0; i < user_array.length; i++)
    //         delete guess_match[user_array[i]];
    // }

    function reset_mapping() public {
        for(uint i = 0; i < guess_array.length; i++){
             guess_array[i] = 0;
             guess_peg[i] = 0;  
        }
        hint = "";
    }

    function getProgress(string memory userCombination) public {
        reset_mapping(); //first clear the previous guess mapping
        bytes memory user = bytes(userCombination);
        bytes memory sol = bytes(solCombination);
        bytes memory u = new bytes(1);

        //Get the black pegs
        for(uint i = 0; i < user.length; i++){
            u[0] = user[0];
            guess_array[i] = 1;
            if(sol[i] == user[i]){
                guess_peg[i] = 2;
                guess_array[i] = 0;
            }
            else{
                guess_peg[i] = 0;
            }
        }
        //red pegs
        for(uint i = 0; i < user.length; i++){
            for(uint j = 0; j < user.length; j++){
                if(user[i] == sol[j] && guess_peg[i] != 2 && guess_array[j] != 0){
                    guess_peg[i] = 1;
                    guess_array[j] = 0;
                }
            }
        } 
        //convert the mapping to string hint to send to front end
        for(uint i = 0; i < user.length; i++)
        {
            hint = string.concat(hint, uint2str(guess_peg[i]));
        }
        console.log("HINT: %s", hint);
    }

    // function getProgress(string memory userCombination) public {
    //     reset_mapping(); //first clear the previous guess mapping
    //     hint = ""; //clear the hint for the current turn
    //     bytes memory user = bytes(userCombination);
    //     bytes memory sol = bytes(solCombination);
    //     bytes memory u = new bytes(1);
    //     user_array = new uint[](sol.length); //This keeps track if an element has already been counted

    //     //Gets the black pegs
    //     for(uint i = 0; i < user_array.length; i++)
    //     {
    //         u[0] = user[i];
    //         if(sol[i] == user[i])
    //         {
    //             guess_match[stringToUint(string(u))] = 2;
                
    //         }
    //         else
    //         {
    //             guess_match[stringToUint(string(u))] = 0;
    //         }
    //         console.log("%d", guess_match[stringToUint(string(u))]);
    //         user_array[i] = 1;
    //     }


    //     // //Gets the red pegs
    //     uint does_it_contain;
    //     for(uint i = 0; i < user.length; i++)
    //     {
    //         does_it_contain = 7;
    //         for(uint j = 0; j < sol.length; j++)
    //         {
    //             if(user[i] == sol[j] && user_array[i] == 1 && i != j)
    //             {
    //                 does_it_contain = i;
    //                 break;
    //             }
    //         }
    //         u[0] = user[i];
    //         if(does_it_contain <= 5 && guess_match[stringToUint(string(u))] != 2)
    //         {
    //             guess_match[stringToUint(string(u))] = 1;
    //             user_array[does_it_contain] = 0;
    //             console.log("Does it Contain index: ", does_it_contain);
    //         }
    //     }
    //     //convert the mapping to string hint to send to front end
    //     for(uint i = 0; i < user.length; i++)
    //     {
    //         u[0] = user[i];
    //         hint = string.concat(hint, uint2str(guess_match[stringToUint(string(u))]));
    //     }
        
    //     console.log("HINT: %s", hint);

    // }



    // function getProgress(string memory userCombination) public {
    //     bytes memory user = bytes(userCombination);
    //     bytes memory sol = bytes(solCombination);
    //     bytes memory u = new bytes(1);
    //     uint exactMatchCount = 0;
    //     uint totalMatchCount = 0;
    //     user_array = new uint[](noColors);
    //     for(uint i = 0; i < user.length; i++)
    //     {
    //         if(user[i] == sol[i])
    //             exactMatchCount++;  
    //         u[0] = user[i];
    //         user_array[stringToUint(string(u))]++;
    //     }

    //     for(uint i = 0; i < noColors; i++)
    //     {
    //         console.log("%d: %d, %d", i, user_array[i], sol_array[i]);
    //     }
    //     for(uint i = 0; i < noColors; i++)
    //     {
    //         if(user_array[i] < sol_array[i]){
    //             totalMatchCount += user_array[i];
    //         }
    //         else{
    //             totalMatchCount += sol_array[i];
    //         }
    //     }
    //     totalMatchCount = totalMatchCount - exactMatchCount;
    //     console.log("Number of exact Matches: %d", exactMatchCount);
    //     console.log("Total number of Matches: %d", totalMatchCount);
    //     hint = string.concat(uint2str(exactMatchCount), hint);
    //     hint = string.concat(hint, uint2str(totalMatchCount));
    // }

    function returnProgress() public view returns (string memory){
        return hint;
    }

}